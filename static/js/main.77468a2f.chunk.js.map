{"version":3,"sources":["api/face.js","views/VideoInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","_loadModels","apply","this","arguments","_callee","MODEL_URL","regenerator_default","a","wrap","_context","prev","next","process","faceapi","stop","getFullFaceDescription","_x","_getFullFaceDescription","_callee2","blob","inputSize","OPTION","useTinyModel","img","fullDesc","_args2","_context2","length","undefined","scoreThreshold","sent","withFaceLandmarks","abrupt","WIDTH","FACE_AREA_THRESHOLD","BRIGHTNESS_THRESHOLD","no_face_message","less_face_area_message","face_out_of_frame_message","brightness_inadequate_message","VideoInput","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","asyncToGenerator","mark","setInputDevice","navigator","mediaDevices","enumerateDevices","then","_ref2","devices","setState","facingMode","startCapture","interval","setInterval","capture","_callee3","_context3","webcam","current","getScreenshot","processCapturePostProcessing","map","fd","detection","window","getCapturedImage","toString","detections","processImageBrightness","canvas","getCanvas","data","getContext","getImageData","width","height","r","g","b","colorSum","x","len","Math","floor","displayMessage","box","i","H","W","X","Y","_y","A","area","parseFloat","brightness","informationMessage","message","react_default","createElement","style","backgroundColor","border","borderColor","marginTop","color","transform","concat","debugMessage","state","renderDetectionMessages","_H","_W","_X","_Y","key","position","React","createRef","match","clearInterval","_this$state","videoConstraints","className","display","flexDirection","alignItems","react_webcam_default","audio","ref","screenshotFormat","Component","App","views_VideoInput","capturedImage","Boolean","location","hostname","image_callback","document","getElementById","getAttribute","ReactDOM","render","src_App_0","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.77468a2f.chunk.js","sourcesContent":["import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.7;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n  return fullDesc;\n}\n\n","import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription } from '../api/face';\n\nconst WIDTH                         = 600;\nconst HEIGHT                        = 600;\nconst inputSize                     = 160;\nconst FACE_AREA_THRESHOLD           = 35000\nconst BRIGHTNESS_THRESHOLD          = 60\nconst no_face_message               = 'please bring your face near to camera'\nconst less_face_area_message        = 'please come near to camera, looks like you are bit from the camera'\nconst face_out_of_frame_message     = 'your full face is not getting captured, please align'\nconst brightness_inadequate_message = 'please enable camera flash or move to a brighter place'\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      match: null,\n      facingMode: null,\n      displayMessage: null,\n      brightness: 0\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      await this.setState({\n        facingMode: 'user'\n      });\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 1500);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          if(this.processCapturePostProcessing(fullDesc.map(fd => fd.detection))) {\n            if (window.getCapturedImage && {}.toString.call(window.getCapturedImage) === '[object Function]') {\n              window.getCapturedImage(this.webcam.current.getScreenshot())\n            }\n          }\n          this.setState({\n            detections: fullDesc.map(fd => fd.detection),\n          });\n        }\n      });\n    }\n  };\n\n  processImageBrightness = () => {\n    let canvas    = this.webcam.current.getCanvas();\n    let ctx       = canvas.getContext('2d');\n    var imageData = ctx.getImageData(0,0,canvas.width,canvas.height);\n    var data      = imageData.data;\n\n    var r = 0, g = 0, b = 0, avg = 0, colorSum = 0;\n\n    for(var x = 0, len = data.length; x < len; x+=4) {\n        r     = data[x];\n        g     = data[x+1];\n        b     = data[x+2];\n        avg   = Math.floor((r+g+b)/3);\n        colorSum += avg;\n    }\n    var brightness = Math.floor(colorSum / (canvas.width * canvas.height));\n    return brightness\n  }\n\n  processCapturePostProcessing = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      this.setState({\n        displayMessage: no_face_message\n      })\n      return false\n    }\n  \n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n    if (parseFloat(box[0]['Y']) < 0.0 || parseFloat(box[0]['X']) < 0.0) {\n      this.setState({\n        displayMessage: face_out_of_frame_message\n      })\n      return false\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      this.setState({\n        displayMessage: less_face_area_message\n      })\n      return false\n    }\n\n    let brightness = this.processImageBrightness()\n    this.setState({\n      brightness: brightness\n    })\n    if ( brightness > BRIGHTNESS_THRESHOLD) {\n    } else {\n      this.setState({\n        displayMessage: brightness_inadequate_message\n      })\n      return false\n    }\n\n    return true\n  }\n\n  informationMessage = (message) => {\n    return (\n      <div>\n        <p style={{ backgroundColor: 'blue', border: 'solid', borderColor: 'blue', width: WIDTH, marginTop: 0, color: '#fff', transform: `translate(-3px,${60}px)`}}>\n          {message}\n        </p>\n      </div>\n    )\n  }\n\n  debugMessage = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      return (<p>Camera: front</p>)\n    }\n\n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n    return <p>H: {box[0]['H']} W: {box[0]['W']} X: {box[0]['X']} Y: {box[0]['Y']} A: {box[0]['A']} B: {this.state.brightness}</p>\n  }\n\n  renderDetectionMessages = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n\n    if (parseFloat(box[0]['Y']) < 0.0 || parseFloat(box[0]['X']) < 0.0) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    if (this.state.brightness !== 0 && this.state.displayMessage != null) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    // all good, draw the box\n    return detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return (\n        <div key={i}>\n          <div\n            style={{\n              position: 'absolute',\n              border: 'solid',\n              borderColor: 'blue',\n              height: _H,\n              width: _W,\n              transform: `translate(${_X}px,${_Y}px)`\n            }}\n          >\n          </div>\n        </div>\n      );\n    });\n  }\n\n  render() {\n    const { detections, facingMode } = this.state;\n    let videoConstraints = null;\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n    }\n\n    return (\n      <div className=\"Camera\" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {this.debugMessage(detections)}\n        <div style={{ width: WIDTH, height: HEIGHT }} >\n          <div style={{ position: 'relative', width: WIDTH, height: HEIGHT}}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {this.renderDetectionMessages(detections)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default VideoInput;","import React, { Component } from 'react';\nimport './App.css';\n\nimport VideoInput from './views/VideoInput';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <VideoInput capturedImage={this.props.capturedImage}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nlet image_callback = document.getElementById('root').getAttribute('capturedImage')\n\nReactDOM.render(<App capturedImage={image_callback} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}