{"version":3,"sources":["api/face.js","views/VideoInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","_loadModels","apply","this","arguments","_callee","MODEL_URL","regenerator_default","a","wrap","_context","prev","next","process","faceapi","stop","getFullFaceDescription","_x","_getFullFaceDescription","_callee2","blob","inputSize","OPTION","useTinyModel","img","fullDesc","_args2","_context2","length","undefined","scoreThreshold","sent","withFaceLandmarks","abrupt","WIDTH","FACE_AREA_THRESHOLD","VideoInput","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","asyncToGenerator","mark","setInputDevice","navigator","mediaDevices","enumerateDevices","then","_ref2","devices","setState","facingMode","startCapture","interval","setInterval","capture","_callee3","_context3","webcam","current","getScreenshot","processCapturePostProcessing","map","fd","detection","window","getCapturedImage","toString","detections","displayMessage","box","i","H","height","W","width","X","Y","_y","A","area","parseFloat","informationMessage","message","react_default","createElement","style","backgroundColor","border","borderColor","marginTop","color","transform","concat","debugMessage","console","log","renderDetectionMessages","state","_H","_W","_X","_Y","key","position","React","createRef","match","clearInterval","_this$state","videoConstraints","className","display","flexDirection","alignItems","react_webcam_default","audio","ref","screenshotFormat","Component","App","views_VideoInput","capturedImage","Boolean","location","hostname","image_callback","document","getElementById","getAttribute","ReactDOM","render","src_App_0","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.91cdb871.chunk.js","sourcesContent":["import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.7;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n  return fullDesc;\n}\n\n","import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription } from '../api/face';\n\nconst WIDTH = 600;\nconst HEIGHT = 600;\nconst inputSize = 160;\nconst FACE_AREA_THRESHOLD = 70000\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      match: null,\n      facingMode: null,\n      displayMessage: null\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      await this.setState({\n        facingMode: 'user'\n      });\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 1500);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          if(this.processCapturePostProcessing(fullDesc.map(fd => fd.detection))) {\n            if (window.getCapturedImage && {}.toString.call(window.getCapturedImage) === '[object Function]') {\n              window.getCapturedImage(this.webcam.current.getScreenshot())\n            }\n          }\n          this.setState({\n            detections: fullDesc.map(fd => fd.detection),\n          });\n        }\n      });\n    }\n  };\n\n  processCapturePostProcessing = (detections) => {\n    let no_face_message             = 'please bring your face near to camera'\n    let less_face_area_message      = 'please come near to camera, looks like you are bit from the camera'\n    let face_out_of_frame_message   = 'your full face is not getting captured, please align'\n  \n    if (!detections || (detections && detections.length === 0)) {\n      this.setState({\n        displayMessage: no_face_message\n      })\n      return false\n    }\n  \n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n    if (parseFloat(box[0]['Y']) < 0.0 || parseFloat(box[0]['X']) < 0.0) {\n      this.setState({\n        displayMessage: face_out_of_frame_message\n      })\n      return false\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      this.setState({\n        displayMessage: less_face_area_message\n      })\n      return false\n    }\n\n    return true\n  }\n\n  informationMessage = (message) => {\n    return (\n      <div>\n        <p style={{ backgroundColor: 'blue', border: 'solid', borderColor: 'blue', width: WIDTH, marginTop: 0, color: '#fff', transform: `translate(-3px,${60}px)`}}>\n          {message}\n        </p>\n      </div>\n    )\n  }\n\n  debugMessage = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      return (<p>Camera: front</p>)\n    }\n\n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n    console.log(box[0])\n\n    return <p>H: {box[0]['H']} W: {box[0]['W']} X: {box[0]['X']} Y: {box[0]['Y']} A: {box[0]['A']}</p>\n\n  }\n\n  renderDetectionMessages = (detections) => {\n\n    if (!detections || (detections && detections.length === 0)) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n\n    if (parseFloat(box[0]['Y']) < 0.0 || parseFloat(box[0]['X']) < 0.0) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    // all good, draw the box\n    return detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return (\n        <div key={i}>\n          <div\n            style={{\n              position: 'absolute',\n              border: 'solid',\n              borderColor: 'blue',\n              height: _H,\n              width: _W,\n              transform: `translate(${_X}px,${_Y}px)`\n            }}\n          >\n          </div>\n        </div>\n      );\n    });\n  }\n\n  render() {\n    const { detections, facingMode } = this.state;\n    let videoConstraints = null;\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n    }\n\n    return (\n      <div className=\"Camera\" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {this.debugMessage(detections)}\n        <div style={{ width: WIDTH, height: HEIGHT }} >\n          <div style={{ position: 'relative', width: WIDTH, height: HEIGHT}}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {this.renderDetectionMessages(detections)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default VideoInput;","import React, { Component } from 'react';\nimport './App.css';\n\nimport VideoInput from './views/VideoInput';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <VideoInput capturedImage={this.props.capturedImage}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nlet image_callback = document.getElementById('root').getAttribute('capturedImage')\n\nReactDOM.render(<App capturedImage={image_callback} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}