{"version":3,"sources":["api/face.js","views/VideoInput.js","App.js","serviceWorker.js","index.js"],"names":["loadModels","_loadModels","apply","this","arguments","_callee","MODEL_URL","regenerator_default","a","wrap","_context","prev","next","process","faceapi","stop","getFullFaceDescription","_x","_getFullFaceDescription","_callee2","blob","inputSize","OPTION","useTinyModel","img","fullDesc","_args2","_context2","length","undefined","scoreThreshold","sent","withFaceLandmarks","abrupt","uuidv4","require","WIDTH","HEIGHT","FACE_AREA_THRESHOLD","BRIGHTNESS_THRESHOLD","MAX_IMAGE_CAPTURES","no_face_message","less_face_area_message","face_out_of_frame_message","brightness_inadequate_message","capture_complete_message","VideoInput","props","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","componentWillMount","asyncToGenerator","mark","setInputDevice","navigator","mediaDevices","enumerateDevices","then","_ref2","devices","setState","facingMode","startCapture","interval","setInterval","capture","_callee3","_context3","webcam","current","getScreenshot","processCapturePostProcessing","map","fd","detection","saveCapturedImages","window","getCapturedImage","toString","detections","data","_this$state","state","capturedImages","capturedCount","push","displayMessage","renderImageURL","react_default","createElement","image","key","download","concat","href","processImageBrightness","canvas","getCanvas","getContext","getImageData","width","height","r","g","b","colorSum","x","len","Math","floor","box","i","H","W","X","Y","_y","A","area","parseFloat","brightness","informationMessage","message","style","backgroundColor","border","borderColor","marginTop","color","transform","debugMessage","renderDetectionMessages","_H","_W","_X","_Y","position","React","createRef","match","clearInterval","_this$state2","videoConstraints","className","display","flexDirection","alignItems","react_webcam_default","audio","ref","screenshotFormat","Component","App","views_VideoInput","capturedImage","Boolean","location","hostname","image_callback","document","getElementById","getAttribute","ReactDOM","render","src_App_0","serviceWorker","ready","registration","unregister"],"mappings":"gUAGO,SAAeA,IAAtB,OAAAC,EAAAC,MAAAC,KAAAC,sDAAO,SAAAC,IAAA,IAAAC,EAAA,OAAAC,EAAAC,EAAAC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cACCN,EAAYO,wBADbH,EAAAE,KAAA,EAECE,IAAkCR,GAFnC,cAAAI,EAAAE,KAAA,EAGCE,IAAkCR,GAHnC,wBAAAI,EAAAK,SAAAV,6BAMA,SAAeW,EAAtBC,GAAA,OAAAC,EAAAhB,MAAAC,KAAAC,sDAAO,SAAAe,EAAsCC,GAAtC,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAtB,UAAA,OAAAG,EAAAC,EAAAC,KAAA,SAAAkB,GAAA,cAAAA,EAAAhB,KAAAgB,EAAAf,MAAA,cAA4CS,EAA5CK,EAAAE,OAAA,QAAAC,IAAAH,EAAA,GAAAA,EAAA,GAAwD,IAExC,GACfJ,EAAS,IAAIR,IAAgC,CACjDO,YACAS,eAHmB,KAKfP,GAAe,EAPhBI,EAAAf,KAAA,EAUWE,IAAmBM,GAV9B,cAUDI,EAVCG,EAAAI,KAAAJ,EAAAf,KAAA,EAcgBE,IACHU,EAAKF,GACpBU,kBAAkBT,GAhBhB,cAcDE,EAdCE,EAAAI,KAAAJ,EAAAM,OAAA,SAiBER,GAjBF,yBAAAE,EAAAZ,SAAAI,6BCNP,IAAMe,EAAgCC,EAAQ,KAExCC,EAAgC,IAChCC,EAAgC,IAChChB,EAAgC,IAChCiB,EAAgC,KAChCC,EAAgC,GAChCC,EAAgC,EAChCC,EAAgC,wCAChCC,EAAgC,qEAChCC,EAAgC,uDAChCC,EAAgC,yDAChCC,EAAgC,uCA8RvBC,cA3Rb,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAA9C,KAAA2C,IACjBE,EAAAC,OAAAE,EAAA,EAAAF,CAAA9C,KAAA8C,OAAAG,EAAA,EAAAH,CAAAH,GAAAO,KAAAlD,KAAM4C,KAcRO,mBAfmBL,OAAAM,EAAA,EAAAN,CAAA1C,EAAAC,EAAAgD,KAeE,SAAAnD,IAAA,OAAAE,EAAAC,EAAAC,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EACbZ,IADa,OAEnBgD,EAAKS,iBAFc,wBAAA/C,EAAAK,SAAAV,MAfF2C,EAoBnBS,eAAiB,WACfC,UAAUC,aAAaC,mBAAmBC,KAA1C,eAAAC,EAAAb,OAAAM,EAAA,EAAAN,CAAA1C,EAAAC,EAAAgD,KAA+C,SAAArC,EAAM4C,GAAN,OAAAxD,EAAAC,EAAAC,KAAA,SAAAkB,GAAA,cAAAA,EAAAhB,KAAAgB,EAAAf,MAAA,cAAAe,EAAAf,KAAA,EACvCoC,EAAKgB,SAAS,CAClBC,WAAY,SAF+B,OAI7CjB,EAAKkB,eAJwC,wBAAAvC,EAAAZ,SAAAI,MAA/C,gBAAAF,GAAA,OAAA6C,EAAA5D,MAAAC,KAAAC,YAAA,KArBiB4C,EA6BnBkB,aAAe,WACblB,EAAKmB,SAAWC,YAAY,WAC1BpB,EAAKqB,WACJ,OAhCcrB,EAuCnBqB,QAvCmBpB,OAAAM,EAAA,EAAAN,CAAA1C,EAAAC,EAAAgD,KAuCT,SAAAc,IAAA,OAAA/D,EAAAC,EAAAC,KAAA,SAAA8D,GAAA,cAAAA,EAAA5D,KAAA4D,EAAA3D,MAAA,WACFoC,EAAKwB,OAAOC,QADV,CAAAF,EAAA3D,KAAA,eAAA2D,EAAA3D,KAAA,EAEAI,EACJgC,EAAKwB,OAAOC,QAAQC,gBACpBrD,GACAwC,KAAK,SAAApC,GACCA,IACDuB,EAAK2B,6BAA6BlD,EAASmD,IAAI,SAAAC,GAAE,OAAIA,EAAGC,eAEzD9B,EAAK+B,mBAAmB/B,EAAKwB,OAAOC,QAAQC,iBAGxCM,OAAOC,kBAAkE,sBAA9C,GAAGC,SAAS7B,KAAK2B,OAAOC,mBACrDD,OAAOC,iBAAiBjC,EAAKwB,OAAOC,QAAQC,kBAGhD1B,EAAKgB,SAAS,CACZmB,WAAY1D,EAASmD,IAAI,SAAAC,GAAE,OAAIA,EAAGC,iBAjBlC,wBAAAP,EAAAxD,SAAAuD,MAvCStB,EA+DnB+B,mBAAqB,SAACK,GAAS,IAAAC,EACWrC,EAAKsC,MAAvCC,EADuBF,EACvBE,eAAgBC,EADOH,EACPG,cAClBD,EAAe3D,OAASY,IAC1B+C,EAAeE,KAAKL,GACpBI,GAAgC,EAEhCxC,EAAKgB,SAAS,CACZuB,eAAgBA,EAChBC,cAAeA,EACfE,eAAgB7C,MAxEHG,EA6EnB2C,eAAiB,WACf,OAAI3C,EAAKsC,MAAME,eAAiBhD,EAE5BoD,EAAApF,EAAAqF,cAAA,WACG7C,EAAKsC,MAAMC,eAAeX,IAAI,SAAAkB,GAAK,OAAIF,EAAApF,EAAAqF,cAAA,KAAGE,IAAK7D,IAAU8D,SAAQ,GAAAC,OAAK/D,IAAL,SAAsBgE,KAAMJ,GAAtD,iBAK1CF,EAAApF,EAAAqF,cAAA,aAtFa7C,EA2FnBmD,uBAAyB,WAQvB,IAPA,IAAIC,EAAYpD,EAAKwB,OAAOC,QAAQ4B,YAGhCjB,EAFYgB,EAAOE,WAAW,MACdC,aAAa,EAAE,EAAEH,EAAOI,MAAMJ,EAAOK,QAC/BrB,KAEtBsB,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAYC,EAAW,EAErCC,EAAI,EAAGC,EAAM3B,EAAKxD,OAAQkF,EAAIC,EAAKD,GAAG,EAC1CJ,EAAQtB,EAAK0B,GACbH,EAAQvB,EAAK0B,EAAE,GACfF,EAAQxB,EAAK0B,EAAE,GAEfD,GADQG,KAAKC,OAAOP,EAAEC,EAAEC,GAAG,GAI/B,OADiBI,KAAKC,MAAMJ,GAAYT,EAAOI,MAAQJ,EAAOK,UA1G7CzD,EA8GnB2B,6BAA+B,SAACQ,GAC9B,IAAKA,GAAeA,GAAoC,IAAtBA,EAAWvD,OAI3C,OAHAoB,EAAKgB,SAAS,CACZ0B,eAAgBjD,KAEX,EAGT,IAAIyE,EAAM/B,EAAWP,IAAI,SAACE,EAAWqC,GAKnC,MAAO,CACLC,EALOtC,EAAUoC,IAAIT,OAAS,GAKvBY,EAJAvC,EAAUoC,IAAIV,MAIPc,EAHPxC,EAAUoC,IAAIjG,GAGAsG,EAFdzC,EAAUoC,IAAIM,GAAK,GAEEC,EAAG3C,EAAUoC,IAAIQ,QAIjD,GAAKC,WAAWT,EAAI,GAAJ,GAAe,GAASS,WAAWT,EAAI,GAAJ,GAAe,GAC7DS,WAAWT,EAAI,GAAJ,GAAeS,WAAWT,EAAI,GAAJ,GAAgB9E,EAAQ,IAC7DuF,WAAWT,EAAI,GAAJ,GAAeS,WAAWT,EAAI,GAAJ,GAAgB7E,EAAS,GAIjE,OAHAW,EAAKgB,SAAS,CACZ0B,eAAgB/C,KAEX,EAGT,GAAIgF,WAAWT,EAAI,GAAJ,GAAe5E,EAI5B,OAHAU,EAAKgB,SAAS,CACZ0B,eAAgBhD,KAEX,EAGT,IAAIkF,EAAa5E,EAAKmD,yBAItB,OAHAnD,EAAKgB,SAAS,CACZ4D,WAAYA,IAETA,EAAarF,IAEhBS,EAAKgB,SAAS,CACZ0B,eAAgB9C,KAEX,IAzJQI,EA+JnB6E,mBAAqB,SAACC,GACpB,OACElC,EAAApF,EAAAqF,cAAA,WACED,EAAApF,EAAAqF,cAAA,KAAGkC,MAAO,CAAEC,gBAAiB,OAAQC,OAAQ,QAASC,YAAa,OAAQ1B,MAAOpE,EAAO+F,UAAW,EAAGC,MAAO,OAAQC,UAAS,kBAAApC,OAAoB,GAApB,SAC5H6B,KAnKU9E,EAyKnBsF,aAAe,SAACnD,GACd,GAAInC,EAAKsC,MAAME,eAAiBhD,EAC9B,OAAOQ,EAAK2C,iBAEZ,IAAKR,GAAeA,GAAoC,IAAtBA,EAAWvD,OAC3C,OAAQgE,EAAApF,EAAAqF,cAAA,0BAGV,IAAIqB,EAAM/B,EAAWP,IAAI,SAACE,EAAWqC,GAKnC,MAAO,CACLC,EALOtC,EAAUoC,IAAIT,OAAS,GAKvBY,EAJAvC,EAAUoC,IAAIV,MAIPc,EAHPxC,EAAUoC,IAAIjG,GAGAsG,EAFdzC,EAAUoC,IAAIM,GAAK,GAEEC,EAAG3C,EAAUoC,IAAIQ,QAGjD,OAAO9B,EAAApF,EAAAqF,cAAA,eAAOqB,EAAI,GAAJ,EAAP,OAAwBA,EAAI,GAAJ,EAAxB,OAAyCA,EAAI,GAAJ,EAAzC,OAA0DA,EAAI,GAAJ,EAA1D,OAA2EA,EAAI,GAAJ,EAA3E,OAA4FlE,EAAKsC,MAAMsC,aA1L/F5E,EA8LnBuF,wBAA0B,SAACpD,GACzB,IAAKA,GAAeA,GAAoC,IAAtBA,EAAWvD,OAC3C,OAAOoB,EAAK6E,mBAAmB7E,EAAKsC,MAAMI,gBAG5C,IAAIwB,EAAM/B,EAAWP,IAAI,SAACE,EAAWqC,GAKnC,MAAO,CACLC,EALOtC,EAAUoC,IAAIT,OAAS,GAKvBY,EAJAvC,EAAUoC,IAAIV,MAIPc,EAHPxC,EAAUoC,IAAIjG,GAGAsG,EAFdzC,EAAUoC,IAAIM,GAAK,GAEEC,EAAG3C,EAAUoC,IAAIQ,QAIjD,OAAKC,WAAWT,EAAI,GAAJ,GAAe,GAASS,WAAWT,EAAI,GAAJ,GAAe,GAC7DS,WAAWT,EAAI,GAAJ,GAAeS,WAAWT,EAAI,GAAJ,GAAgB9E,EAAQ,IAC7DuF,WAAWT,EAAI,GAAJ,GAAeS,WAAWT,EAAI,GAAJ,GAAgB7E,EAAS,GAC1DW,EAAK6E,mBAAmB7E,EAAKsC,MAAMI,gBAGxCiC,WAAWT,EAAI,GAAJ,GAAe5E,EACrBU,EAAK6E,mBAAmB7E,EAAKsC,MAAMI,iBAGd,IAA1B1C,EAAKsC,MAAMsC,YAAiD,MAA7B5E,EAAKsC,MAAMI,gBAC5C1C,EAAK6E,mBAAmB7E,EAAKsC,MAAMI,gBAGjC1C,EAAKsC,MAAME,eAAkBhD,GAC/BQ,EAAK6E,mBAAmB7E,EAAKsC,MAAMI,gBAI9BP,EAAWP,IAAI,SAACE,EAAWqC,GAChC,IAAIqB,EAAK1D,EAAUoC,IAAIT,OAAS,GAC5BgC,EAAK3D,EAAUoC,IAAIV,MACnBkC,EAAK5D,EAAUoC,IAAIjG,GACnB0H,EAAK7D,EAAUoC,IAAIM,GAAK,GAC5B,OACE5B,EAAApF,EAAAqF,cAAA,OAAKE,IAAKoB,GACRvB,EAAApF,EAAAqF,cAAA,OACEkC,MAAO,CACLa,SAAU,WACVX,OAAQ,QACRC,YAAa,OACbzB,OAAQ+B,EACRhC,MAAOiC,EACPJ,UAAS,aAAApC,OAAeyC,EAAf,OAAAzC,OAAuB0C,EAAvB,eA5OnB3F,EAAKwB,OAASqE,IAAMC,YACpB9F,EAAKsC,MAAQ,CACX7D,SAAU,KACV0D,WAAY,KACZ4D,MAAO,KACP9E,WAAY,KACZyB,eAAgB,KAChBkC,WAAY,EACZrC,eAAgB,GAChBC,cAAe,GAXAxC,sFAoCjBgG,cAAc7I,KAAKgE,2CAmNZ,IAAA8E,EAC4B9I,KAAKmF,MAAhCH,EADD8D,EACC9D,WAAYlB,EADbgF,EACahF,WAChBiF,EAAmB,KASvB,OARMjF,IACJiF,EAAmB,CACjB1C,MAAOpE,EACPqE,OAAQpE,EACR4B,WAAYA,IAKd2B,EAAApF,EAAAqF,cAAA,OAAKsD,UAAU,SAASpB,MAAO,CAAEqB,QAAS,OAAQC,cAAe,SAAUC,WAAY,WACpFnJ,KAAKmI,aAAanD,GACnBS,EAAApF,EAAAqF,cAAA,OAAKkC,MAAO,CAAEvB,MAAOpE,EAAOqE,OAAQpE,IAClCuD,EAAApF,EAAAqF,cAAA,OAAKkC,MAAO,CAAEa,SAAU,WAAYpC,MAAOpE,EAAOqE,OAAQpE,IACrD6G,EACDtD,EAAApF,EAAAqF,cAAA,OAAKkC,MAAO,CAAEa,SAAU,aACtBhD,EAAApF,EAAAqF,cAAC0D,EAAA/I,EAAD,CACEgJ,OAAO,EACPhD,MAAOpE,EACPqE,OAAQpE,EACRoH,IAAKtJ,KAAKqE,OACVkF,iBAAiB,aACjBR,iBAAkBA,KAGpB,KACH/I,KAAKoI,wBAAwBpD,aApRjBwE,aCDVC,mLARX,OACEhE,EAAApF,EAAAqF,cAAA,OAAKsD,UAAU,OACbvD,EAAApF,EAAAqF,cAACgE,EAAD,CAAYC,cAAe3J,KAAK4C,MAAM+G,wBAL5BH,aCOEI,QACW,cAA7B/E,OAAOgF,SAASC,UAEe,UAA7BjF,OAAOgF,SAASC,UAEhBjF,OAAOgF,SAASC,SAASlB,MACvB,2DCZN,IAAImB,EAAiBC,SAASC,eAAe,QAAQC,aAAa,iBAElEC,IAASC,OAAO3E,EAAApF,EAAAqF,cAAC2E,EAAD,CAAKV,cAAeI,IAAoBC,SAASC,eAAe,SDyH1E,kBAAmB1G,WACrBA,UAAU+G,cAAcC,MAAM7G,KAAK,SAAA8G,GACjCA,EAAaC","file":"static/js/main.19e02bbb.chunk.js","sourcesContent":["import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.7;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n  return fullDesc;\n}\n\n","import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription } from '../api/face';\nconst uuidv4                        = require('uuid/v4')\n\nconst WIDTH                         = 600;\nconst HEIGHT                        = 600;\nconst inputSize                     = 160;\nconst FACE_AREA_THRESHOLD           = 35000\nconst BRIGHTNESS_THRESHOLD          = 60\nconst MAX_IMAGE_CAPTURES            = 6\nconst no_face_message               = 'please bring your face near to camera'\nconst less_face_area_message        = 'please come near to camera, looks like you are bit from the camera'\nconst face_out_of_frame_message     = 'your full face is not getting captured, please align'\nconst brightness_inadequate_message = 'please enable camera flash or move to a brighter place'\nconst capture_complete_message      = 'we have captured the relevant images'\n\nclass VideoInput extends Component {\n  constructor(props) {\n    super(props);\n    this.webcam = React.createRef();\n    this.state = {\n      fullDesc: null,\n      detections: null,\n      match: null,\n      facingMode: null,\n      displayMessage: null,\n      brightness: 0,\n      capturedImages: [],\n      capturedCount: 0\n    };\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      await this.setState({\n        facingMode: 'user'\n      });\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval(() => {\n      this.capture();\n    }, 1500);\n  };\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (!!this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (!!fullDesc) {\n          if(this.processCapturePostProcessing(fullDesc.map(fd => fd.detection))) {\n            // save the appropriate images\n            this.saveCapturedImages(this.webcam.current.getScreenshot())\n\n            // make callback\n            if (window.getCapturedImage && {}.toString.call(window.getCapturedImage) === '[object Function]') {\n              window.getCapturedImage(this.webcam.current.getScreenshot())\n            }\n          }\n          this.setState({\n            detections: fullDesc.map(fd => fd.detection),\n          });\n        }\n      });\n    }\n  };\n\n  saveCapturedImages = (data) => {\n    let { capturedImages, capturedCount } = this.state;\n    if (capturedImages.length < MAX_IMAGE_CAPTURES) {\n      capturedImages.push(data)\n      capturedCount = capturedCount + 1\n\n      this.setState({\n        capturedImages: capturedImages,\n        capturedCount: capturedCount,\n        displayMessage: capture_complete_message\n      })\n    }\n  }\n\n  renderImageURL = () => {\n    if (this.state.capturedCount >= MAX_IMAGE_CAPTURES) {\n      return(\n        <div>\n          {this.state.capturedImages.map(image => <a key={uuidv4()} download={`${uuidv4()}.jpeg`} href={image}> Download </a>)}\n        </div>\n      )\n    } else {\n      return (\n        <div></div>\n      )\n    }\n  }\n\n  processImageBrightness = () => {\n    let canvas    = this.webcam.current.getCanvas();\n    let ctx       = canvas.getContext('2d');\n    var imageData = ctx.getImageData(0,0,canvas.width,canvas.height);\n    var data      = imageData.data;\n\n    var r = 0, g = 0, b = 0, avg = 0, colorSum = 0;\n\n    for(var x = 0, len = data.length; x < len; x+=4) {\n        r     = data[x];\n        g     = data[x+1];\n        b     = data[x+2];\n        avg   = Math.floor((r+g+b)/3);\n        colorSum += avg;\n    }\n    var brightness = Math.floor(colorSum / (canvas.width * canvas.height));\n    return brightness\n  }\n\n  processCapturePostProcessing = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      this.setState({\n        displayMessage: no_face_message\n      })\n      return false\n    }\n  \n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n\n    if ((parseFloat(box[0]['Y']) < 0.0) || (parseFloat(box[0]['X']) < 0.0) || \n        (parseFloat(box[0]['X']) + parseFloat(box[0]['W']) > (WIDTH - 50)) ||\n        (parseFloat(box[0]['Y']) + parseFloat(box[0]['H']) > (HEIGHT - 50))) {\n      this.setState({\n        displayMessage: face_out_of_frame_message\n      })\n      return false\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      this.setState({\n        displayMessage: less_face_area_message\n      })\n      return false\n    }\n\n    let brightness = this.processImageBrightness()\n    this.setState({\n      brightness: brightness\n    })\n    if ( brightness > BRIGHTNESS_THRESHOLD) {\n    } else {\n      this.setState({\n        displayMessage: brightness_inadequate_message\n      })\n      return false\n    }\n\n    return true\n  }\n\n  informationMessage = (message) => {\n    return (\n      <div>\n        <p style={{ backgroundColor: 'blue', border: 'solid', borderColor: 'blue', width: WIDTH, marginTop: 0, color: '#fff', transform: `translate(-3px,${60}px)`}}>\n          {message}\n        </p>\n      </div>\n    )\n  }\n\n  debugMessage = (detections) => {\n    if (this.state.capturedCount >= MAX_IMAGE_CAPTURES) {\n      return this.renderImageURL()\n    } else {\n      if (!detections || (detections && detections.length === 0)) {\n        return (<p>Camera: front</p>)\n      }\n\n      let box = detections.map((detection, i) => {\n        let _H = detection.box.height + 50;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y - 80;\n        return {\n          H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n        }\n      })\n      return <p>H: {box[0]['H']} W: {box[0]['W']} X: {box[0]['X']} Y: {box[0]['Y']} A: {box[0]['A']} B: {this.state.brightness}</p>\n    }\n  }\n\n  renderDetectionMessages = (detections) => {\n    if (!detections || (detections && detections.length === 0)) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    let box = detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return {\n        H: _H, W: _W, X: _X, Y: _Y, A: detection.box.area\n      }\n    })\n\n    if ((parseFloat(box[0]['Y']) < 0.0) || (parseFloat(box[0]['X']) < 0.0) || \n        (parseFloat(box[0]['X']) + parseFloat(box[0]['W']) > (WIDTH - 50)) ||\n        (parseFloat(box[0]['Y']) + parseFloat(box[0]['H']) > (HEIGHT - 50))) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    if (parseFloat(box[0]['A']) < FACE_AREA_THRESHOLD) {\n      return this.informationMessage(this.state.displayMessage)\n    }\n\n    if (this.state.brightness !== 0 && this.state.displayMessage != null) {\n      this.informationMessage(this.state.displayMessage)\n    }\n\n    if (this.state.capturedCount >=  MAX_IMAGE_CAPTURES) {\n      this.informationMessage(this.state.displayMessage)\n    }\n  \n    // all good, draw the box\n    return detections.map((detection, i) => {\n      let _H = detection.box.height + 50;\n      let _W = detection.box.width;\n      let _X = detection.box._x;\n      let _Y = detection.box._y - 80;\n      return (\n        <div key={i}>\n          <div\n            style={{\n              position: 'absolute',\n              border: 'solid',\n              borderColor: 'blue',\n              height: _H,\n              width: _W,\n              transform: `translate(${_X}px,${_Y}px)`\n            }}\n          >\n          </div>\n        </div>\n      );\n    });\n  }\n\n  render() {\n    const { detections, facingMode } = this.state;\n    let videoConstraints = null;\n    if (!!facingMode) {\n      videoConstraints = {\n        width: WIDTH,\n        height: HEIGHT,\n        facingMode: facingMode\n      };\n    }\n\n    return (\n      <div className=\"Camera\" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>\n        {this.debugMessage(detections)}\n        <div style={{ width: WIDTH, height: HEIGHT }} >\n          <div style={{ position: 'relative', width: WIDTH, height: HEIGHT}}>\n            {!!videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={WIDTH}\n                  height={HEIGHT}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {this.renderDetectionMessages(detections)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default VideoInput;","import React, { Component } from 'react';\nimport './App.css';\n\nimport VideoInput from './views/VideoInput';\n\nclass App extends Component {\n\n  render() {\n    return (\n      <div className=\"App\">\n        <VideoInput capturedImage={this.props.capturedImage}/>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nlet image_callback = document.getElementById('root').getAttribute('capturedImage')\n\nReactDOM.render(<App capturedImage={image_callback} />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}